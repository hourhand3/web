<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è´ªåƒè›‡ - æ™ºèƒ½è‡ªåŠ¨ç©ï¼ˆé•¿è›‡å®‰å…¨ç‰ˆï¼‰</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        #gameContainer {
            text-align: center;
            margin-right: 20px;
        }
        
        #gameBoard {
            border: 2px solid black;
            margin-top: 10px;
        }
        
        #controlPanel {
            margin: 15px 0;
        }
        
        button, select, input {
            padding: 6px 10px;
            margin: 4px;
            font-size: 14px;
        }
        
        .color-section {
            margin-top: 12px;
            display: none;
        }
        
        .color-input-group {
            display: inline-block;
            margin: 0 8px;
            vertical-align: top;
        }
        
        .color-input-group label {
            display: block;
            font-size: 12px;
        }
        
        .color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid #999;
            display: inline-block;
            vertical-align: middle;
            margin-left: 6px;
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .preset-row {
            margin-bottom: 6px;
        }
        
        .color-block {
            margin-bottom: 12px;
        }
        
        #historyPanel {
            width: 300px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 10px;
            position: sticky;
            top: 20px;
            height: fit-content;
        }
        
        #historyList {
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
        }
        
        .history-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            word-wrap: break-word;
        }
        
        .history-item:hover {
            background-color: #e0e0e0;
        }
        
        #loadStateInput {
            width: 100%;
            padding: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        #loadStateBtn {
            padding: 6px 10px;
            font-size: 14px;
            width: 100%;
            margin-top: 5px;
        }
        
        .history-controls {
            margin-top: 10px;
        }
        
        .instructions {
            margin-top: 15px;
            padding: 10px;
            background-color: #e7f3ff;
            border-radius: 5px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">å¾—åˆ†: 0</div>
        <canvas id="gameBoard" width="500" height="500"></canvas>
        <div id="controlPanel">
            <button id="startBtn">å¼€å§‹æ¸¸æˆ</button>
            <button id="autoBtn">è‡ªåŠ¨ç©</button>
            <button id="pauseBtn">æš‚åœ</button>
            <button id="saveHistoryBtn">ä¿å­˜å†å²</button>
            <select id="colorMode">
                <option value="rainbow">ğŸŒˆ å½©è™¹è‰²</option>
                <option value="single">ğŸŸ¢ å•è‰²æ¸å˜ï¼ˆæ·±â†’æµ…ï¼‰</option>
                <option value="dual">ğŸ”´ğŸ”µ åŒè‰²æ¸å˜ï¼ˆå¤´â†’å°¾ï¼‰</option>
            </select>
        </div>

        <!-- å•è‰²è®¾ç½® -->
        <div id="singleColorSection" class="color-section">
            <div class="preset-row">
                <button data-rgb="0,128,0">ğŸŸ¢ ç»¿</button>
                <button data-rgb="255,0,0">ğŸ”´ çº¢</button>
                <button data-rgb="0,0,255">ğŸ”µ è“</button>
                <button data-rgb="128,0,128">ğŸŸ£ ç´«</button>
                <button data-rgb="255,165,0">ğŸŸ  æ©™</button>
                <button data-rgb="0,255,255">ğŸ”· é’</button>
            </div>
            <div>
                <div class="color-input-group">
                    <label>R (0-255)</label>
                    <input type="number" id="singleR" min="0" max="255" value="0">
                </div>
                <div class="color-input-group">
                    <label>G (0-255)</label>
                    <input type="number" id="singleG" min="0" max="255" value="128">
                </div>
                <div class="color-input-group">
                    <label>B (0-255)</label>
                    <input type="number" id="singleB" min="0" max="255" value="0">
                </div>
                <div class="color-input-group">
                    <label>åŸºç¡€è‰²</label>
                    <div class="color-preview" id="singlePreview"></div>
                    <span id="singleValue">rgb(0,128,0)</span>
                </div>
            </div>
        </div>

        <!-- åŒè‰²è®¾ç½® -->
        <div id="dualColorSection" class="color-section">
            <!-- å¤´éƒ¨é¢œè‰² -->
            <div class="color-block head-colors">
                <strong>å¤´éƒ¨é¢œè‰²</strong>
                <div class="preset-row">
                    <button data-rgb="255,0,0">ğŸ”´ çº¢</button>
                    <button data-rgb="0,255,0">ğŸŸ¢ ç»¿</button>
                    <button data-rgb="0,0,255">ğŸ”µ è“</button>
                    <button data-rgb="255,255,0">ğŸŸ¡ é»„</button>
                    <button data-rgb="255,0,255">.Magenta</button>
                </div>
                <div>
                    <div class="color-input-group">
                        <label>R</label>
                        <input type="number" id="headR" min="0" max="255" value="255">
                    </div>
                    <div class="color-input-group">
                        <label>G</label>
                        <input type="number" id="headG" min="0" max="255" value="0">
                    </div>
                    <div class="color-input-group">
                        <label>B</label>
                        <input type="number" id="headB" min="0" max="255" value="0">
                    </div>
                    <div class="color-input-group">
                        <div class="color-preview" id="headPreview"></div>
                        <span id="headValue">rgb(255,0,0)</span>
                    </div>
                </div>
            </div>

            <!-- å°¾éƒ¨é¢œè‰² -->
            <div class="color-block tail-colors">
                <strong>å°¾éƒ¨é¢œè‰²</strong>
                <div class="preset-row">
                    <button data-rgb="0,0,255">ğŸ”µ è“</button>
                    <button data-rgb="0,255,0">ğŸŸ¢ ç»¿</button>
                    <button data-rgb="255,255,255">âšª ç™½</button>
                    <button data-rgb="128,128,128">âš« ç°</button>
                    <button data-rgb="0,0,0">â¬› é»‘</button>
                </div>
                <div>
                    <div class="color-input-group">
                        <label>R</label>
                        <input type="number" id="tailR" min="0" max="255" value="0">
                    </div>
                    <div class="color-input-group">
                        <label>G</label>
                        <input type="number" id="tailG" min="0" max="255" value="0">
                    </div>
                    <div class="color-input-group">
                        <label>B</label>
                        <input type="number" id="tailB" min="0" max="255" value="255">
                    </div>
                    <div class="color-input-group">
                        <div class="color-preview" id="tailPreview"></div>
                        <span id="tailValue">rgb(0,0,255)</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <strong>æ“ä½œè¯´æ˜:</strong><br>
            â€¢ æ–¹å‘é”®/WASD: æ§åˆ¶è›‡çš„æ–¹å‘<br>
            â€¢ è‡ªåŠ¨ç©æ—¶æ— æ³•ä½¿ç”¨é”®ç›˜æ§åˆ¶<br>
            â€¢ æ¸¸æˆç»“æŸåçŠ¶æ€è‡ªåŠ¨ä¿å­˜
        </div>
    </div>

    <!-- å³ä¾§å†å²è®°å½•é¢æ¿ -->
    <div id="historyPanel">
        <h3>å†å²è®°å½•</h3>
        <div>
            <input type="text" id="loadStateInput" placeholder="ç²˜è´´çŠ¶æ€ç ä»¥åŠ è½½">
            <button id="loadStateBtn">åŠ è½½çŠ¶æ€</button>
        </div>
        <div id="historyList"></div>
        <div class="history-controls">
            <button id="clearHistoryBtn">æ¸…ç©ºå†å²</button>
        </div>
    </div>

    <script>
        // ========== DOM å…ƒç´  ==========
        const canvas = document.getElementById('gameBoard');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startBtn = document.getElementById('startBtn');
        const autoBtn = document.getElementById('autoBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const saveHistoryBtn = document.getElementById('saveHistoryBtn');
        const loadStateInput = document.getElementById('loadStateInput');
        const loadStateBtn = document.getElementById('loadStateBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const historyList = document.getElementById('historyList');
        const colorModeSelect = document.getElementById('colorMode');

        const singleSection = document.getElementById('singleColorSection');
        const dualSection = document.getElementById('dualColorSection');

        // å•è‰²è¾“å…¥
        const singleR = document.getElementById('singleR');
        const singleG = document.getElementById('singleG');
        const singleB = document.getElementById('singleB');
        const singlePreview = document.getElementById('singlePreview');
        const singleValue = document.getElementById('singleValue');

        // åŒè‰²è¾“å…¥
        const headR = document.getElementById('headR');
        const headG = document.getElementById('headG');
        const headB = document.getElementById('headB');
        const headPreview = document.getElementById('headPreview');
        const headValue = document.getElementById('headValue');

        const tailR = document.getElementById('tailR');
        const tailG = document.getElementById('tailG');
        const tailB = document.getElementById('tailB');
        const tailPreview = document.getElementById('tailPreview');
        const tailValue = document.getElementById('tailValue');

        // é¢œè‰²æ•°æ®
        let colorMode = 'rainbow';
        let singleColor = { r: 0, g: 128, b: 0 };
        let headColor = { r: 255, g: 0, b: 0 };
        let tailColor = { r: 0, g: 0, b: 255 };

        // ========== å·¥å…·å‡½æ•° ==========
        function clamp(val, min, max) {
            return Math.min(Math.max(parseInt(val) || 0, min), max);
        }

        function updateColorDisplay(inputR, inputG, inputB, preview, valueSpan, colorObj) {
            const r = clamp(inputR.value, 0, 255);
            const g = clamp(inputG.value, 0, 255);
            const b = clamp(inputB.value, 0, 255);
            inputR.value = r;
            inputG.value = g;
            inputB.value = b;
            colorObj.r = r;
            colorObj.g = g;
            colorObj.b = b;
            const str = `rgb(${r},${g},${b})`;
            preview.style.backgroundColor = str;
            valueSpan.textContent = str;
            if (colorMode === 'single' || colorMode === 'dual') drawGame();
        }

        // ========== åˆå§‹åŒ–é¢œè‰²æ˜¾ç¤º ==========
        function initColorDisplays() {
            updateColorDisplay(singleR, singleG, singleB, singlePreview, singleValue, singleColor);
            updateColorDisplay(headR, headG, headB, headPreview, headValue, headColor);
            updateColorDisplay(tailR, tailG, tailB, tailPreview, tailValue, tailColor);
        }

        // ========== RGB â†’ HSL / HSL â†’ RGB ==========
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            let red, green, blue;
            if (s === 0) {
                red = green = blue = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                red = hue2rgb(p, q, h + 1/3);
                green = hue2rgb(p, q, h);
                blue = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255)];
        }

        // ========== é¢œè‰²è·å–å‡½æ•° ==========
        function getSegmentColor(index, total) {
            const t = index / Math.max(1, total - 1);

            switch (colorMode) {
                case 'rainbow':
                    return `hsl(${(t * 360) % 360}, 100%, 55%)`;
                case 'single':
                    const hsl = rgbToHsl(singleColor.r, singleColor.g, singleColor.b);
                    const lightness = 30 + t * 50;
                    const [r, g, b] = hslToRgb(hsl.h, hsl.s, lightness);
                    return `rgb(${r},${g},${b})`;
                case 'dual':
                    const red = Math.round(headColor.r * (1 - t) + tailColor.r * t);
                    const green = Math.round(headColor.g * (1 - t) + tailColor.g * t);
                    const blue = Math.round(headColor.b * (1 - t) + tailColor.b * t);
                    return `rgb(${red},${green},${blue})`;
                default:
                    return 'green';
            }
        }

        // ========== çŠ¶æ€åºåˆ—åŒ–ä¸ååºåˆ—åŒ– ==========
        function serializeGameState() {
            // åˆ›å»ºä¸€ä¸ª25x25çš„ç½‘æ ¼ï¼Œç”¨ä½å›¾è¡¨ç¤º
            const grid = new Array(25).fill(null).map(() => new Array(25).fill(0));
            
            // æ ‡è®°è›‡çš„ä½ç½® (ä½¿ç”¨1)
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                if (segment.x >= 0 && segment.x < 25 && segment.y >= 0 && segment.y < 25) {
                    grid[segment.y][segment.x] = 1;
                }
            }
            
            // æ ‡è®°é£Ÿç‰©ä½ç½® (ä½¿ç”¨2)
            grid[food.y][food.x] = 2;
            
            // å°†2ç»´æ•°ç»„è½¬æ¢ä¸ºä½å›¾
            const bits = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 25; x++) {
                    bits.push(grid[y][x]);
                }
            }
            
            // å°†ä½å›¾è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„ï¼ˆæ¯2ä½å­˜å‚¨åœ¨ä¸€ä¸ªå­—èŠ‚ä¸­ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åŒºåˆ†0,1,2ä¸‰ç§çŠ¶æ€ï¼‰
            // ä½¿ç”¨base64ç¼–ç æ¥è¡¨ç¤ºçŠ¶æ€
            const bytes = [];
            for (let i = 0; i < bits.length; i += 4) { // æ¯4ä¸ªçŠ¶æ€å€¼ç”¨ä¸€ä¸ªå­—èŠ‚è¡¨ç¤ºï¼ˆ2ä½*4=8ä½ï¼‰
                let byte = 0;
                for (let j = 0; j < 4; j++) {
                    const bitIndex = i + j;
                    if (bitIndex < bits.length) {
                        const state = bits[bitIndex]; // 0, 1, or 2
                        byte |= (state << (j * 2)); // æ¯ä¸ªçŠ¶æ€å 2ä½
                    }
                }
                bytes.push(byte);
            }
            
            // æ·»åŠ æ–¹å‘ä¿¡æ¯å’Œåˆ†æ•°
            const directionCode = ['up', 'down', 'left', 'right'].indexOf(direction);
            bytes.push(directionCode);
            bytes.push(score & 0xFF); // åˆ†æ•°ä½8ä½
            bytes.push((score >> 8) & 0xFF); // åˆ†æ•°é«˜8ä½
            
            // è½¬æ¢ä¸ºBase64å­—ç¬¦ä¸²
            const binaryString = String.fromCharCode(...bytes);
            return btoa(binaryString);
        }

        function deserializeGameState(stateStr) {
            try {
                const binaryString = atob(stateStr);
                const bytes = Array.from(binaryString, char => char.charCodeAt(0));
                
                // æå–æ–¹å‘å’Œåˆ†æ•°ä¿¡æ¯ï¼ˆä»æœ«å°¾å¼€å§‹ï¼‰
                const scoreHigh = bytes.pop();
                const scoreLow = bytes.pop();
                const directionCode = bytes.pop();
                
                score = (scoreHigh << 8) | scoreLow;
                direction = ['up', 'down', 'left', 'right'][directionCode];
                nextDirection = direction;
                
                // é‡å»ºä½å›¾
                const bits = [];
                for (let i = 0; i < bytes.length; i++) {
                    const byte = bytes[i];
                    for (let j = 0; j < 4; j++) {
                        const state = (byte >> (j * 2)) & 3; // æå–2ä½
                        bits.push(state);
                    }
                }
                
                // é‡å»ºç½‘æ ¼
                const grid = new Array(25).fill(null).map(() => new Array(25).fill(0));
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 25; x++) {
                        const idx = y * 25 + x;
                        if (idx < bits.length) {
                            grid[y][x] = bits[idx];
                        }
                    }
                }
                
                // é‡å»ºè›‡å’Œé£Ÿç‰©
                snake = [];
                food = null;
                
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 25; x++) {
                        if (grid[y][x] === 1) {
                            snake.push({ x, y });
                        } else if (grid[y][x] === 2) {
                            food = { x, y };
                        }
                    }
                }
                
                if (!food) {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é£Ÿç‰©ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„
                    generateFood();
                }
                
                scoreElement.textContent = `å¾—åˆ†: ${score}`;
                drawGame();
                return true;
            } catch (e) {
                console.error("çŠ¶æ€è§£æå¤±è´¥:", e);
                alert("çŠ¶æ€ç æ— æ•ˆæˆ–å·²æŸåï¼");
                return false;
            }
        }

        // ========== å†å²è®°å½•ç®¡ç† ==========
        let gameStateHistory = JSON.parse(localStorage.getItem('snakeGameHistory') || '[]');

        function saveToHistory() {
            const stateStr = serializeGameState();
            const timestamp = new Date().toLocaleString();
            const historyItem = {
                state: stateStr,
                score: score,
                timestamp: timestamp,
                length: snake.length
            };
            
            gameStateHistory.unshift(historyItem); // æ·»åŠ åˆ°å¼€å¤´
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            if (gameStateHistory.length > 20) {
                gameStateHistory = gameStateHistory.slice(0, 20);
            }
            
            localStorage.setItem('snakeGameHistory', JSON.stringify(gameStateHistory));
            loadHistory(); // æ›´æ–°å†å²åˆ—è¡¨
            alert("å½“å‰çŠ¶æ€å·²ä¿å­˜åˆ°å†å²è®°å½•ï¼");
        }

        function loadHistory() {
            historyList.innerHTML = '';
            if (gameStateHistory.length === 0) {
                historyList.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">æš‚æ— å†å²è®°å½•</div>';
                return;
            }
            
            gameStateHistory.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.innerHTML = `
                    <strong>ç¬¬${index + 1}æ¡è®°å½•</strong><br>
                    å¾—åˆ†: ${item.score}, é•¿åº¦: ${item.length}<br>
                    æ—¶é—´: ${item.timestamp}<br>
                    <small>${item.state.substring(0, 30)}...</small>
                `;
                div.onclick = () => {
                    if (deserializeGameState(item.state)) {
                        // åŠ è½½æˆåŠŸåä¸éœ€è¦å…³é—­ä»»ä½•ä¸œè¥¿ï¼Œç›´æ¥æ›´æ–°æ¸¸æˆçŠ¶æ€
                    }
                };
                historyList.appendChild(div);
            });
        }

        function clearHistory() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚")) {
                gameStateHistory = [];
                localStorage.removeItem('snakeGameHistory');
                loadHistory();
            }
        }

        // ========== æ¸¸æˆé€»è¾‘ ==========
        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let gameLoop;
        let score = 0;
        let isAuto = false;
        let isPaused = false;
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        function initGame() {
            snake = [
                { x: 5, y: 5 },
                { x: 4, y: 5 },
                { x: 3, y: 5 }
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            scoreElement.textContent = `å¾—åˆ†: ${score}`;
            generateFood();
            drawGame();
        }

        function generateFood() {
            food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    generateFood();
                    return;
                }
            }
        }

        function drawGame() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                ctx.fillStyle = getSegmentColor(i, snake.length);
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
            }

            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
        }

        function checkCollision(x, y) {
            return snake.some(segment => segment.x === x && segment.y === y);
        }

        // ========== BFS å¯»è·¯ ==========
        function findPath() {
            const visited = new Set();
            const queue = [];
            const head = snake[0];
            const obstacles = new Set(snake.map(seg => `${seg.x},${seg.y}`));
            queue.push({ x: head.x, y: head.y, path: [] });
            visited.add(`${head.x},${head.y}`);
            while (queue.length > 0) {
                const current = queue.shift();
                if (current.x === food.x && current.y === food.y) return current.path;
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];
                for (let neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`;
                    if (
                        neighbor.x >= 0 && neighbor.x < tileCount &&
                        neighbor.y >= 0 && neighbor.y < tileCount &&
                        !obstacles.has(key) &&
                        !visited.has(key)
                    ) {
                        visited.add(key);
                        queue.push({ x: neighbor.x, y: neighbor.y, path: [...current.path, neighbor] });
                    }
                }
            }
            return [];
        }

        // ========== ğŸ”¥ ç»ˆæå®‰å…¨æ£€æŸ¥ï¼šå¤šæ­¥å‰ç»æ€§ Flood Fill ==========
        function isPathSafe(path) {
            if (path.length === 0) return false;

            // å…‹éš†å½“å‰è›‡ï¼ˆé¿å…ä¿®æ”¹åŸæ•°æ®ï¼‰
            let simulatedSnake = [...snake];
            const maxSteps = path.length + 1; // åŒ…æ‹¬åƒé£Ÿç‰©é‚£ä¸€æ­¥

            // æ¨¡æ‹Ÿä»å½“å‰åˆ°åƒæ‰é£Ÿç‰©åçš„æ¯ä¸€æ­¥
            for (let stepIndex = 0; stepIndex < maxSteps; stepIndex++) {
                let nextHead;
                if (stepIndex < path.length) {
                    nextHead = { ...path[stepIndex] };
                } else {
                    // æœ€åä¸€æ­¥ï¼šåƒæ‰é£Ÿç‰©ï¼Œé•¿åº¦+1
                    nextHead = { ...food };
                }

                // ç§»åŠ¨è›‡å¤´
                simulatedSnake.unshift(nextHead);
                if (stepIndex < path.length) {
                    // è¿˜æ²¡åƒåˆ°é£Ÿç‰©ï¼Œæ­£å¸¸ç§»åŠ¨ï¼ˆé•¿åº¦ä¸å˜ï¼‰
                    simulatedSnake.pop();
                }
                // åƒåˆ°é£Ÿç‰©åä¸ popï¼Œé•¿åº¦è‡ªç„¶ +1

                const currentLength = simulatedSnake.length;
                const obstacles = new Set(simulatedSnake.map(seg => `${seg.x},${seg.y}`));
                const head = simulatedSnake[0];

                // å¿«é€Ÿå¤±è´¥ï¼šå…¨å±€ç©ºæ ¼ä¸è¶³
                if (tileCount * tileCount - obstacles.size < currentLength) {
                    return false;
                }

                // Flood Fillï¼šè®¡ç®—ä»å½“å‰å¤´éƒ¨å¯è¾¾çš„ç©ºæ ¼æ•°
                const visited = new Set();
                const queue = [{ x: head.x, y: head.y }];
                visited.add(`${head.x},${head.y}`);
                let reachable = 0;

                while (queue.length > 0) {
                    const { x, y } = queue.shift();
                    reachable++;

                    // æå‰ç»ˆæ­¢ï¼šå¦‚æœå·²è¶³å¤Ÿå¤§ï¼Œæ— éœ€ç»§ç»­éå†
                    if (reachable >= currentLength) break;

                    const neighbors = [
                        { x: x + 1, y: y },
                        { x: x - 1, y: y },
                        { x: x, y: y + 1 },
                        { x: x, y: y - 1 }
                    ];

                    for (let nb of neighbors) {
                        if (
                            nb.x >= 0 && nb.x < tileCount &&
                            nb.y >= 0 && nb.y < tileCount
                        ) {
                            const key = `${nb.x},${nb.y}`;
                            if (!obstacles.has(key) && !visited.has(key)) {
                                visited.add(key);
                                queue.push(nb);
                            }
                        }
                    }
                }

                // å…³é”®ï¼šæ¯ä¸€æ­¥éƒ½å¿…é¡»æ»¡è¶³ç©ºé—´ â‰¥ å½“å‰è›‡é•¿
                if (reachable < currentLength) {
                    return false;
                }
            }

            return true; // å…¨ç¨‹å®‰å…¨
        }

        // ========== å®‰å…¨æ¢ç´¢æ¨¡å¼ ==========
        function safeExplore() {
            const head = snake[0];
            const directions = ['up', 'down', 'left', 'right'];
            const moves = [];

            for (let dir of directions) {
                let nx = head.x, ny = head.y;
                switch (dir) {
                    case 'up': ny--; break;
                    case 'down': ny++; break;
                    case 'left': nx--; break;
                    case 'right': nx++; break;
                }

                if (
                    nx >= 0 && nx < tileCount &&
                    ny >= 0 && ny < tileCount &&
                    !checkCollision(nx, ny)
                ) {
                    // è®¡ç®—ç¦»èº«ä½“çš„æœ€å°æ›¼å“ˆé¡¿è·ç¦»ï¼ˆè¶Šå¤§è¶Šå®‰å…¨ï¼‰
                    let minDist = Infinity;
                    for (let i = 1; i < snake.length; i++) {
                        const seg = snake[i];
                        const dist = Math.abs(nx - seg.x) + Math.abs(ny - seg.y);
                        if (dist < minDist) minDist = dist;
                    }
                    moves.push({ dir, safety: minDist });
                }
            }

            if (moves.length === 0) return;

            // ä¼˜å…ˆä¿æŒå½“å‰æ–¹å‘ï¼ˆå¦‚æœå®‰å…¨ï¼‰
            const currentMove = moves.find(m => m.dir === direction);
            if (currentMove) {
                nextDirection = currentMove.dir;
            } else {
                // å¦åˆ™é€‰æœ€å®‰å…¨çš„æ–¹å‘
                moves.sort((a, b) => b.safety - a.safety);
                nextDirection = moves[0].dir;
            }
        }

        // ========== è‡ªåŠ¨å†³ç­– ==========
        function autoMove() {
            if (!isAuto) return;

            const path = findPath();
            let shouldUsePath = false;

            if (path.length > 0 && isPathSafe(path)) {
                shouldUsePath = true;
            }

            if (shouldUsePath) {
                const nextStep = path[0];
                const head = snake[0];
                if (nextStep.x > head.x) nextDirection = 'right';
                else if (nextStep.x < head.x) nextDirection = 'left';
                else if (nextStep.y > head.y) nextDirection = 'down';
                else if (nextStep.y < head.y) nextDirection = 'up';
            } else {
                safeExplore();
            }

            // é˜²æ­¢ 180Â° è½¬å‘
            if (
                (direction === 'up' && nextDirection === 'down') ||
                (direction === 'down' && nextDirection === 'up') ||
                (direction === 'left' && nextDirection === 'right') ||
                (direction === 'right' && nextDirection === 'left')
            ) {
                return;
            }
            direction = nextDirection;
        }

        // ========== æ¸¸æˆä¸»å¾ªç¯ ==========
        function gameStep() {
            if (isPaused) return;
            
            // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼Œåˆ™æ‰§è¡Œè‡ªåŠ¨å†³ç­–
            if (isAuto) {
                autoMove();
            } else {
                // å¦‚æœä¸æ˜¯è‡ªåŠ¨æ¨¡å¼ï¼Œä»…æ›´æ–°æ–¹å‘ï¼ˆé˜²æ­¢180åº¦è½¬å‘ï¼‰
                if (
                    (direction === 'up' && nextDirection === 'down') ||
                    (direction === 'down' && nextDirection === 'up') ||
                    (direction === 'left' && nextDirection === 'right') ||
                    (direction === 'right' && nextDirection === 'left')
                ) {
                    // ä¸æ”¹å˜æ–¹å‘ï¼Œä¿æŒåŸæ¥çš„æ–¹å‘
                } else {
                    direction = nextDirection;
                }
            }

            const head = { x: snake[0].x, y: snake[0].y };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // æ’å¢™æˆ–æ’è‡ªå·±
            if (
                head.x < 0 || head.x >= tileCount ||
                head.y < 0 || head.y >= tileCount ||
                checkCollision(head.x, head.y)
            ) {
                gameOver();
                return;
            }

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreElement.textContent = `å¾—åˆ†: ${score}`;
                generateFood();
            } else {
                snake.pop();
            }
            drawGame();
        }

        function gameOver() {
            clearInterval(gameLoop);
            // ä¿å­˜æœ€ç»ˆçŠ¶æ€åˆ°å†å²è®°å½•
            saveToHistory();
            alert(`æ¸¸æˆç»“æŸï¼å¾—åˆ†: ${score}\næœ€ç»ˆçŠ¶æ€å·²è‡ªåŠ¨ä¿å­˜åˆ°å†å²è®°å½•ä¸­ï¼`);
            startBtn.textContent = "é‡æ–°å¼€å§‹";
            isAuto = false;
            isPaused = false;
            autoBtn.textContent = "è‡ªåŠ¨ç©";
            pauseBtn.textContent = "æš‚åœ";
        }

        // ========== äº‹ä»¶ç»‘å®š ==========
        colorModeSelect.addEventListener('change', () => {
            colorMode = colorModeSelect.value;
            singleSection.style.display = colorMode === 'single' ? 'block' : 'none';
            dualSection.style.display = colorMode === 'dual' ? 'block' : 'none';
            drawGame();
        });

        [singleR, singleG, singleB].forEach(input => {
            input.addEventListener('input', () => updateColorDisplay(singleR, singleG, singleB, singlePreview, singleValue, singleColor));
        });

        [headR, headG, headB, tailR, tailG, tailB].forEach(input => {
            input.addEventListener('input', () => {
                updateColorDisplay(headR, headG, headB, headPreview, headValue, headColor);
                updateColorDisplay(tailR, tailG, tailB, tailPreview, tailValue, tailColor);
            });
        });

        // å•è‰²é¢„è®¾
        document.querySelectorAll('#singleColorSection button[data-rgb]').forEach(btn => {
            btn.addEventListener('click', () => {
                const [r, g, b] = btn.dataset.rgb.split(',').map(Number);
                singleR.value = r;
                singleG.value = g;
                singleB.value = b;
                updateColorDisplay(singleR, singleG, singleB, singlePreview, singleValue, singleColor);
            });
        });

        // åŒè‰²é¢„è®¾
        document.querySelectorAll('.head-colors button[data-rgb]').forEach(btn => {
            btn.addEventListener('click', () => {
                const [r, g, b] = btn.dataset.rgb.split(',').map(Number);
                headR.value = r;
                headG.value = g;
                headB.value = b;
                updateColorDisplay(headR, headG, headB, headPreview, headValue, headColor);
            });
        });

        document.querySelectorAll('.tail-colors button[data-rgb]').forEach(btn => {
            btn.addEventListener('click', () => {
                const [r, g, b] = btn.dataset.rgb.split(',').map(Number);
                tailR.value = r;
                tailG.value = g;
                tailB.value = b;
                updateColorDisplay(tailR, tailG, tailB, tailPreview, tailValue, tailColor);
            });
        });

        // é”®ç›˜æ§åˆ¶ - æ”¯æŒæ–¹å‘é”®å’ŒWASD
        document.addEventListener('keydown', (e) => {
            if (isAuto || isPaused) return; // è‡ªåŠ¨æ¨¡å¼æˆ–æš‚åœæ—¶ä¸æ¥å—é”®ç›˜è¾“å…¥
            
            switch (e.key.toLowerCase()) {
                case 'arrowup': 
                case 'w': 
                    if (direction !== 'down') nextDirection = 'up'; 
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢é¡µé¢æ»šåŠ¨
                    break;
                case 'arrowdown': 
                case 's': 
                    if (direction !== 'up') nextDirection = 'down'; 
                    e.preventDefault();
                    break;
                case 'arrowleft': 
                case 'a': 
                    if (direction !== 'right') nextDirection = 'left'; 
                    e.preventDefault();
                    break;
                case 'arrowright': 
                case 'd': 
                    if (direction !== 'left') nextDirection = 'right'; 
                    e.preventDefault();
                    break;
            }
        });

        // æŒ‰é’®æ§åˆ¶
        startBtn.addEventListener('click', () => {
            clearInterval(gameLoop);
            initGame();
            gameLoop = setInterval(gameStep, 100);
            startBtn.textContent = "é‡æ–°å¼€å§‹";
            isPaused = false;
            pauseBtn.textContent = "æš‚åœ";
        });

        autoBtn.addEventListener('click', () => {
            isAuto = !isAuto;
            autoBtn.textContent = isAuto ? "æ‰‹åŠ¨ç©" : "è‡ªåŠ¨ç©";
            // åœ¨è‡ªåŠ¨æ¨¡å¼åˆ‡æ¢æ—¶æç¤ºç”¨æˆ·é”®ç›˜æ§åˆ¶çŠ¶æ€
            if (isAuto) {
                alert("å·²è¿›å…¥è‡ªåŠ¨æ¨¡å¼ï¼Œé”®ç›˜æ§åˆ¶å·²ç¦ç”¨");
            } else {
                alert("å·²é€€å‡ºè‡ªåŠ¨æ¨¡å¼ï¼Œç°åœ¨å¯ä»¥ç”¨é”®ç›˜æ§åˆ¶");
            }
        });

        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? "ç»§ç»­" : "æš‚åœ";
        });

        // å†å²è®°å½•æŒ‰é’®
        saveHistoryBtn.addEventListener('click', () => {
            saveToHistory();
        });

        loadStateBtn.addEventListener('click', () => {
            const stateStr = loadStateInput.value.trim();
            if (stateStr) {
                if (deserializeGameState(stateStr)) {
                    loadStateInput.value = '';
                }
            }
        });

        clearHistoryBtn.addEventListener('click', () => {
            clearHistory();
        });

        // åˆå§‹åŒ–
        initColorDisplays();
        initGame();
        loadHistory(); // åŠ è½½å†å²è®°å½•ç”¨äºåˆå§‹åŒ–
    </script>
</body>
</html>
